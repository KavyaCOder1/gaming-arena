generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── User ─────────────────────────────────────────────────────────────────────
model User {
  id          String    @id
  username    String    @unique
  password    String
  createdAt   DateTime  @default(now())
  lastLoginAt DateTime?

  level        UserLevel?
  tttGames     TicTacToeGame[]
  wsGames      WordSearchGame[]
  pacmanGames      PacmanGame[]
  pacmanSessions   PacmanSession[]
  leaderboard  Leaderboard[]
  tttSessions  TicTacToeSession[]
  wsSessions   WordSearchSession[]
  memoryGames      MemoryGame[]
  memorySessions   MemorySession[]
  snakeSessions         SnakeSession[]          @relation("SnakeSessions")
  snakeGames            SnakeGame[]             @relation("SnakeGames")
  spaceShooterSessions  SpaceShooterSession[]   @relation("SpaceShooterSessions")
  spaceShooterGames     SpaceShooterGame[]      @relation("SpaceShooterGames")
  connectDotsSessions   ConnectDotsSession[]    @relation("ConnectDotsSessions")
  connectDotsGames      ConnectDotsGame[]       @relation("ConnectDotsGames")
}

// ─── Level / XP ───────────────────────────────────────────────────────────────
model UserLevel {
  id        String   @id @default(cuid())
  userId    String   @unique
  xp        Int      @default(0)
  rank      UserRank @default(ROOKIE)
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ─── Active Tic-Tac-Toe Session (server owns all game logic) ──────────────────
// One row = one live game. Created by POST /api/games/ttt/start.
// The server is the ONLY thing that writes board, aiLastCell, result, finished.
// Client sends only: sessionId + playerCell. Server computes AI, updates board,
// returns new state. Client cannot lie about anything.
model TicTacToeSession {
  id          String         @id @default(cuid())
  userId      String
  difficulty  GameDifficulty
  board       String         // JSON: (null|"X"|"O")[]  — 9 cells
  aiLastCell  Int?           // last cell AI played (returned to client for animation)
  result      GameResult?    // set by server when game ends
  finished    Boolean        @default(false)
  startedAt   DateTime       @default(now())
  finishedAt  DateTime?
  savedAt     DateTime?      // stamped by /move when game ends — /finish is read-only after
  score       Int?           // computed by /move on game end, read back by /finish
  xpEarned    Int?           // computed by /move on game end, read back by /finish

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, finished])
}

// ─── Permanent Tic-Tac-Toe game record ────────────────────────────────────────
model TicTacToeGame {
  id         String         @id @default(cuid())
  userId     String
  result     GameResult
  difficulty GameDifficulty
  score      Int
  xpEarned   Int            @default(0)
  duration   Int
  createdAt  DateTime       @default(now())
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, createdAt(sort: Desc)])
}

// ─── Active Word Search Session (server-authoritative) ──────────────────────────
// Server generates grid + places words. Client only reports which cells it selected.
// On finish, XP is awarded only if all words were found (completed = true).
model WordSearchSession {
  id           String         @id @default(cuid())
  userId       String
  difficulty   GameDifficulty
  gridSize     Int
  gridData     String         // JSON: string[][] — the full grid
  placedWords  String         // JSON: PlacedWord[] — { word, cells }[]
  foundWords   String         @default("[]") // JSON: string[] — words validated by server
  totalWords   Int
  finished     Boolean        @default(false)
  completed    Boolean        @default(false)  // true if all words found
  startedAt    DateTime       @default(now())
  completedAt  DateTime?      // stamped by /validate when last word found — duration source of truth
  savedAt      DateTime?      // stamped by /validate on completion (read-only after)
  xpEarned     Int?           // computed + stored by /validate on completion

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, finished])
}

// ─── Word Search game records ─────────────────────────────────────────────────
model WordSearchGame {
  id         String         @id @default(cuid())
  userId     String
  difficulty GameDifficulty
  score      Int
  xpEarned   Int            @default(0)
  wordsFound Int
  totalWords Int
  completed  Boolean        @default(false)
  duration   Int
  createdAt  DateTime       @default(now())
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, createdAt(sort: Desc)])
}

// ─── Pacman active session (security token) ─────────────────────────────────────
model PacmanSession {
  id              String    @id @default(cuid())
  userId          String
  token           String    @unique  // HMAC session token — passed to iframe
  startedAt       DateTime  @default(now())
  used            Boolean   @default(false)   // set true by /finish atomically
  expiresAt       DateTime  // startedAt + 2h
  // Committed score — written by /commit, read by /finish. Client cannot alter.
  committedScore  Int?      // score stored at commit time
  committedStage  Int?      // stage stored at commit time
  commitAt        DateTime? // when /commit was called
  receipt         String?   @unique // HMAC receipt = proof score is unaltered
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, used])
  @@index([expiresAt])  // for cleanup
}

// ─── Pacman game records ────────────────────────────────────────────────────────
model PacmanGame {
  id        String   @id @default(cuid())
  userId    String
  score     Int
  stage     Int      @default(1)
  xpEarned  Int      @default(0)
  duration  Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, createdAt(sort: Desc)])
  @@index([score(sort: Desc)])
}

// ─── Leaderboard ──────────────────────────────────────────────────────────────
model Leaderboard {
  id         String          @id @default(cuid())
  userId     String
  gameType   GameType
  difficulty GameDifficulty? // null for difficulty-less games like PACMAN
  highScore  Int
  updatedAt  DateTime        @updatedAt
  user       User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([userId, gameType, difficulty])
  @@index([gameType, highScore(sort: Desc)])
}

// ─── Memory active session (server-authoritative) ──────────────────────────────
// Server shuffles + stores the deck. Client only sends flip requests.
// Server tracks which cards are matched — client cannot lie.
model MemorySession {
  id           String         @id @default(cuid())
  userId       String
  difficulty   GameDifficulty
  deckData     String         // JSON: { id, sym, pairId }[] — full shuffled deck
  matchedPairs String         @default("[]") // JSON: number[] — matched pairIds
  totalPairs   Int
  moves        Int            @default(0)
  finished     Boolean        @default(false)
  completed    Boolean        @default(false)
  startedAt    DateTime       @default(now())
  completedAt  DateTime?      // stamped by /flip when last pair matched — duration source of truth
  savedAt      DateTime?      // stamped by /finish after writing permanent record
  score        Int?           // computed by /flip on completion, read back by /finish
  xpEarned     Int?           // computed by /flip on completion, read back by /finish

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, finished])
}

// ─── Memory game records ─────────────────────────────────────────────────────
model MemoryGame {
  id         String         @id @default(cuid())
  userId     String
  difficulty GameDifficulty
  score      Int
  xpEarned   Int            @default(0)
  moves      Int
  matched    Int
  duration   Int
  createdAt  DateTime       @default(now())
  user       User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId, createdAt(sort: Desc)])
}

model SnakeSession {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation("SnakeSessions", fields: [userId], references: [id], onDelete: Cascade)
  
  difficulty        String    // easy, medium, hard
  coresCollected    Int       @default(0)
  survivalTime      Int       @default(0)
  score             Int       @default(0)
  snakeLength       Int       @default(3)
  
  gameStartedAt     DateTime  @default(now())
  createdAt         DateTime  @default(now())
  
  @@index([userId])
  @@index([createdAt])
}

model SnakeGame {
  id                String    @id @default(cuid())
  userId            String
  user              User      @relation("SnakeGames", fields: [userId], references: [id], onDelete: Cascade)
  
  difficulty        String    // easy, medium, hard
  coresCollected    Int
  survivalTime      Int
  score             Int
  snakeLength       Int
  xpEarned          Int
  
  savedAt           DateTime  @default(now())
  createdAt         DateTime  @default(now())
  
  @@index([userId])
  @@index([xpEarned])
  @@index([createdAt])
}

// ─── Connect The Dots (session + game) ───────────────────────────────────────

model ConnectDotsSession {
  id               String         @id @default(cuid())
  userId           String
  user             User           @relation("ConnectDotsSessions", fields: [userId], references: [id], onDelete: Cascade)

  difficulty       GameDifficulty
  dotsCount       Int
  timeLimitSeconds Int

  startedAt        DateTime       @default(now())
  createdAt        DateTime       @default(now())

  @@index([userId])
  @@index([createdAt])
}

model ConnectDotsGame {
  id               String         @id @default(cuid())
  userId           String
  user             User           @relation("ConnectDotsGames", fields: [userId], references: [id], onDelete: Cascade)

  difficulty       GameDifficulty
  dotsCount        Int
  timeLimitSeconds Int
  completed        Boolean
  moves            Int
  duration         Int
  xpEarned         Int

  createdAt        DateTime       @default(now())

  @@index([userId])
  @@index([xpEarned])
  @@index([createdAt])
}

// ─── Enums ────────────────────────────────────────────────────────────────────
model SpaceShooterSession {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation("SpaceShooterSessions", fields: [userId], references: [id], onDelete: Cascade)
  startedAt DateTime @default(now())
  createdAt DateTime @default(now())
  @@index([userId])
}

model SpaceShooterGame {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation("SpaceShooterGames", fields: [userId], references: [id], onDelete: Cascade)
  score        Int
  wave         Int
  kills        Int
  survivalTime Int
  xpEarned     Int
  savedAt      DateTime @default(now())
  createdAt    DateTime @default(now())
  @@index([userId])
  @@index([score(sort: Desc)])
  @@index([createdAt])
}

enum GameType {
  WORD_SEARCH
  TIC_TAC_TOE
  MEMORY
  PACMAN
  SNAKE
  SPACE_SHOOTER
  CONNECT_DOTS
}

enum GameDifficulty {
  EASY
  MEDIUM
  HARD
}

enum GameResult {
  WIN
  LOSE
  DRAW
}

enum UserRank {
  ROOKIE
  VETERAN
  ELITE
  LEGEND
}
